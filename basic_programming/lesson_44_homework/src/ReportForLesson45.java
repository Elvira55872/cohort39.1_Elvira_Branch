public class ReportForLesson45 {
    public static void main(String[] args) {
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 5; i++) {
                    System.out.println(Thread.currentThread().getName() + i);
                }
            }
        });

        // Мы научились:
        // ДАВАТЬ ИМЯ ПОТОКУ
        t1.setName("Поток 1");
        /*
        Рекомендуется давать потокам осмысленные имена, это пригодится при отладке.
        Не рекомендуется давать потокам одинаковые имена, хотя это допустимо
         */

        // ДАВАТЬ ПОТОКУ ПРИОРИТЕТ
        t1.setPriority(10);
        /*
        максимальный = 10
        минимальный = 1

        если мы не устанавливаем вручную приоритет потоку, то он будет выставлен по умолчанию и будет равен 5
        т.к. у потока Main приоритет 5

        Необязательно будет быстрее всего выполнен поток с бОльшим приоритетом,
        тк потоки уходят выполняться на разные ядра и поток с меньшим приоритетом может быть выполнен быстрее
        Мы не можем на это повлиять

        Поток с большим приоритетом будет иметь больше процессорного времени на выполнение.
        Если два потока имеют одинаковый приоритет, то решение о том, какой из них будет выполняться первым,
        зависит от алгоритма планировщика

        Thread.MIN_PRIORITY — минимальный приоритет, значение 1;
        Thread.NORM_PRIORITY — приоритет по умолчанию, значение 5;
        Thread.MAX_PRIORITY — максимальный приоритет потока, значение 10
         */

        // ОБРАЩЕНИЕ К ПОТОКУ
        Thread.currentThread().setPriority(5);
        /*
        так можно обратиться к потоку
        в этом примере мы обратимся к потоку Main, тк находимся сейчас в нем

        Чтобы обратиться к другому потоку, нужно обращение писать в его теле
         */

        /*
        ПОТОКИ - ДЕМОНЫ
        Работа JVM заканчивается, когда закончил выполняться последний поток не-демон,
        несмотря на работающие потоки-демоны.
         */

        t1.setDaemon(true);
        t1.isDaemon();

        /*
         ОСТАНОВКА ПОТОКА

         Остановка через stop() уже устарела и работает некорректно
         Сейчас используют остановку через interrupt()
         */

        t1.interrupt(); // возвращает значение флага и устанавливает его значение в false.
        // Если флаг interrupted установлен в true и вызывается этот метод, то первый раз метод вернет true,
        // а последующие вызовы вернут false.

        /*
        изначально у всех потоков флаг interrupt() стоит в позиции FALSE
        t1.interrupt(); после этой команды флаг станет TRUE

        Когда поток прерывается другим потоком, происходит одно из двух:

            1. Если поток ожидает выполнения прерываемого метода блокирования,
        таких как Thread.sleep(), Thread.join() или Object.wait(),
        то ожидание прерывается и метод генерирует InterruptedException. Флаг interrupted устанавливается в false.
            2. Флаг interrupted устанавливается в true.
         */

        t1.isInterrupted(); // не меняет флаг, просто возвращает его значение


    }
}
